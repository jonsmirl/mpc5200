Bottom: 3920f08cae61b17a06ef205d52be042611fdbe14
Top:    82e16b6cc590445470ad55b81276f9480adcf232
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2008-12-15 15:12:14 -0500

i2c driver for Maxim max9485 audio clock generator chip

i2c driver for Maxim max9485 audio clock generator chip

Signed-off-by: Jon Smirl <jonsmirl@gmail.com>





---

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index fee7304..6ffd693 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -413,6 +413,15 @@ config ATMEL_SSC
 
 	  If unsure, say N.
 
+config MAX9485
+	tristate "Maxim MAX9485 Programmable Audio Clock Generator"
+	help
+	  If you say yes here you get support for Maxim MAX9485 
+	  Programmable Audio Clock Generator.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called max9485.
+
 config INTEL_MENLOW
 	tristate "Thermal Management driver for Intel menlow platform"
 	depends on ACPI_THERMAL
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 817f7f5..1b5a079 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_THINKPAD_ACPI)	+= thinkpad_acpi.o
 obj-$(CONFIG_FUJITSU_LAPTOP)	+= fujitsu-laptop.o
 obj-$(CONFIG_PANASONIC_LAPTOP)	+= panasonic-laptop.o
 obj-$(CONFIG_EEPROM_93CX6)	+= eeprom_93cx6.o
+obj-$(CONFIG_MAX9485)		+= max9485.o
 obj-$(CONFIG_INTEL_MENLOW)	+= intel_menlow.o
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
diff --git a/drivers/misc/max9485.c b/drivers/misc/max9485.c
new file mode 100644
index 0000000..c1316f2
--- /dev/null
+++ b/drivers/misc/max9485.c
@@ -0,0 +1,105 @@
+/*
+ * Maxim max9485 Programmable Audio Clock Generator driver
+ *
+ * Written by: Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Copyright (C) 2008 Digispeaker.com
+ * Copyright (C) 2008 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This device is usually under the control of ALSA and should not be changed
+ * from userspace. The main purpose of this driver is to locate the i2c address
+ * of where the chip is located.
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/sysfs.h>
+#include <linux/i2c/max9485.h>
+
+int max9485_set(struct i2c_client *max9485, u8 value)
+{
+	return i2c_smbus_write_byte(max9485, value);
+}
+EXPORT_SYMBOL_GPL(max9485_set);
+
+/*
+ * Display the only register
+ */
+static ssize_t max9485_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int rc;
+
+	rc = i2c_smbus_read_byte(client);
+	if (rc < 0)
+		return rc;
+
+	return sprintf(buf, "%s%s%s%s%s%s",
+			(rc & MAX9485_MCLK ? "MCLK+" : ""),
+			(rc & MAX9485_CLK_OUT_2 ? "CLK2+" : ""),
+			(rc & MAX9485_CLK_OUT_2 ? "CLK1+" : ""),
+			(rc & MAX9485_DOUBLED ? "DOUBLED+" : ""),
+			(rc & MAX9485_SCALE_768 ? "768x+" : (rc & MAX9485_SCALE_384 ? "384x+" : "256x+")),
+			((rc & 3) == MAX9485_FREQUENCY_48 ? "48Khz" :
+			((rc & 3) == MAX9485_FREQUENCY_441 ? "44.1Khz" :
+			((rc & 3) == MAX9485_FREQUENCY_32 ? "32Khz" : "12Khz"))));
+}
+static DEVICE_ATTR(max9485, S_IRUGO, max9485_show, NULL);
+
+/*
+ * Called when a max9485 device is matched with this driver
+ */
+static int max9485_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {
+		dev_err(&client->dev, "i2c bus does not support the max9485\n");
+		return -ENODEV;
+	}
+	return sysfs_create_file(&client->dev.kobj, &dev_attr_max9485.attr);
+}
+
+static int max9485_remove(struct i2c_client *client)
+{
+	sysfs_remove_file(&client->dev.kobj, &dev_attr_max9485.attr);
+	return 0;
+}
+
+static const struct i2c_device_id max9485_id[] = {
+	{ "max9485", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max9485_id);
+
+static struct i2c_driver max9485_driver = {
+	.driver = {
+		.name = "max9485",
+	},
+	.probe = max9485_probe,
+	.remove = max9485_remove,
+	.id_table = max9485_id,
+};
+
+static int __init max9485_init(void)
+{
+	return i2c_add_driver(&max9485_driver);
+}
+
+static void __exit max9485_exit(void)
+{
+	i2c_del_driver(&max9485_driver);
+}
+
+MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com");
+MODULE_DESCRIPTION("Maxim MAX9485 Programmable Audio Clock Generator driver");
+MODULE_LICENSE("GPL");
+
+module_init(max9485_init);
+module_exit(max9485_exit);
diff --git a/include/linux/i2c/max9485.h b/include/linux/i2c/max9485.h
new file mode 100644
index 0000000..81543bb
--- /dev/null
+++ b/include/linux/i2c/max9485.h
@@ -0,0 +1,39 @@
+/*
+ * Maxim max9485 Programmable Audio Clock Generator driver
+ *
+ * Written by: Jon Smirl <jonsmirl@gmail.com>
+ *
+ * Copyright (C) 2008 Digispeaker.com
+ * Copyright (C) 2008 Jon Smirl <jonsmirl@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_I2C_MAX9485_H
+#define __LINUX_I2C_MAX9485_H
+
+struct i2c_client;
+
+/* Defines for Maxim MAX9485 Audio Clock Generator */
+
+#define MAX9485_MCLK         (1 << 7)
+#define MAX9485_CLK_OUT_2    (1 << 6)
+#define MAX9485_CLK_OUT_1    (1 << 5)
+#define MAX9485_DOUBLED      (1 << 4)
+#define MAX9485_SCALE_256    (0 << 2)
+#define MAX9485_SCALE_384    (1 << 2)
+#define MAX9485_SCALE_768    (2 << 2)
+#define MAX9485_FREQUENCY_12  0
+#define MAX9485_FREQUENCY_32  1
+#define MAX9485_FREQUENCY_441 2
+#define MAX9485_FREQUENCY_48  3
+
+/* Combinations that minimize jitter */
+#define MAX9485_245760 (MAX9485_SCALE_256 | MAX9485_FREQUENCY_48 | MAX9485_DOUBLED)
+#define MAX9485_225792 (MAX9485_SCALE_256 | MAX9485_FREQUENCY_441 | MAX9485_DOUBLED)
+
+int max9485_set(struct i2c_client *max9485, u8 value);
+
+#endif /*  __LINUX_I2C_MAX9485_H */
